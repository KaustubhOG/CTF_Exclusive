
## Rust — detailed writeup

**The issue:** The challenge project imported `xor_cryptor::XORCryptor` but compilation failed with:

```
error[E0432]: unresolved import `xor_cryptor`
```

That basically means the compiler couldn’t find the crate or the symbol inside it.

**First thoughts:**

* Maybe the crate wasn’t in `Cargo.toml` or the version was wrong.
* Maybe the type name is mis-capitalized (Rust is strict with naming).
* Or maybe the crate just doesn’t exist anymore.

**Approach I took:** Instead of spending time on Cargo registry issues, I thought: *what does this crate actually do?* The name `xor_cryptor` made it obvious: it just applies XOR with a key over some bytes. That’s a one-liner in Rust.

**Quick re-implementation:**

```rust
struct XORCryptor {
    key: Vec<u8>,
}

impl XORCryptor {
    fn new(key: &[u8]) -> Self { Self { key: key.to_vec() } }
    fn apply(&self, data: &mut [u8]) {
        for (i, b) in data.iter_mut().enumerate() {
            *b ^= self.key[i % self.key.len()];
        }
    }
}
```

That’s enough to unlock the challenge code.

**Running it:** After swapping in the above snippet instead of the external crate, the project compiled fine. Running it produced the expected flag (the challenge’s output).

**Why this works in CTF context:**

* Challenges often include broken or outdated dependencies on purpose.
* The point isn’t to fix the dependency but to understand the logic.
* Re-implementing a missing function is usually faster than debugging Cargo for an hour.

**Lessons learned:**

* In Rust, `unresolved import` usually means either missing dependency or wrong path. Always check docs or crate page first.
* For CTFs, don’t waste too much time fixing build systems. Re-implement the core logic if it’s simple.
* XOR “encryption” is trivial, so even without the crate, guessing the intended function was easy.

**Fix (if you wanted to be proper):** Add the dependency in `Cargo.toml` correctly:

```toml
[dependencies]
xor_cryptor = "0.1.3"
```

Run `cargo update` and it might work. But in this case, skipping it was faster.

**End result:** We got the flag by patching in a tiny local struct and moving on.

---

## Repo layout

```
ctf-writeups/
├── ssti/README.md
└── rust_challenge/README.md
```
